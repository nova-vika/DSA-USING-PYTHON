# Given an integer array nums, return true if any value appears more than once in the array, otherwise return false.
 
 # solution :  
   
 # Three methods to solve “Contains Duplicate” :

   #   ⭐ Method 1: Brute Force (The “Check Every Pair” Method)
   #   ⭐ Method 2: Sorting Method (The “Line-Up” Method)
   #   ⭐ Method 3: Hashing / Set Method (The “Sticker Book” Method)

# _________________________________________________________________________________________________________
# |Method	                            Explanation	                                       Fast?           |
# |_______________________________________________________________________________________________________ |
# |Brute Force	              Compare every marble with every other marble	             ❌ Slow          |
# |Sorting	                  Line marbles smallest → biggest; check neighbors       	⚡ Medium         |
# |Hashing (Set)	          Put marbles in a sticker book; if repeat → duplicate	    ⚡⚡⚡ Fastest   |
# |________________________________________________________________________________________________________|  

#------------------------------------------------------
#1) Brute-Force (compare every pair)                   |
#   def containsDuplicate(nums):                       |
#    for i in range(len(nums)):                        |
#        for j in range(i + 1, len(nums)):             |
#            if nums[i] == nums[j]:                    |
#               return True                            |
#    return False                                      |
#-------------------------------------------------------

#Line-by-line:

# def containsDuplicate(nums):
# Defines a function named containsDuplicate that takes a list nums.

# for i in range(len(nums)):
# Outer loop: i goes through every index 0..n-1. We pick an element at index i.

# for j in range(i + 1, len(nums)):
# Inner loop: j goes through indexes after i (so we compare each pair only once and avoid comparing an element with itself).

# if nums[i] == nums[j]:
# If the element at i equals the element at j, we found a duplicate.

# return True
# Immediately return True because a duplicate exists.

# return False (after loops)
# If we finished all pairs without a match, no duplicates exist → return False.

# Example trace for nums = [1,2,3,1]:

# i=0 compare with j=1,2,3; when j=3 nums[0] == nums[3] → return True.

# Complexity:
# Time: O(n²) (checks ~n*(n-1)/2 pairs).
# Space: O(1) (no extra data structures). 

#------------------------------------------------------
# 2) Sorting + neighbor check                         |
# def containsDuplicate(nums):                        |
#  nums.sort()                                        |
#    for i in range(len(nums) - 1):                   |
#        if nums[i] == nums[i + 1]:                   |
#            return True                              |
#    return False                                     |
#-------------------------------------------------------

# Line-by-line:

# nums.sort()
# Sorts the list in-place so equal values become adjacent.

# for i in range(len(nums) - 1):
# Loop through indices 0..n-2 (we stop at n-2 because we compare i with i+1).

# if nums[i] == nums[i + 1]:
# If an element equals its immediate neighbor, that means a duplicate exists.

# return True
# Stop early if duplicate found.

# return False
# If the loop finishes, there were no adjacent equal pairs → no duplicates.

# Why len(nums) - 1?
# Because i+1 must be a valid index. If i reached len(nums)-1, i+1 would be out of range.

# Example trace for nums = [3,1,4,1]:

# After sort() → [1,1,3,4].

# i=0: compare 1 and 1 → equal → return True.

# Complexity:
# Time: O(n log n) (sorting dominates).
# Space: O(1) extra if sort is in-place (or O(n) depending on language/implementation).

#-------------------------------------------------------
# 3) Hashing (set) — recommended for speed             |
# def containsDuplicate(nums):                         |
#     seen = set()                                     |
#     for num in nums:                                 |
#       if num in seen:                                |
#            return True                               |
#        seen.add(num)                                 |
#    return False                                      |
#-------------------------------------------------------

# Line-by-line:

# seen = set()
# Create an empty set to remember numbers we’ve seen so far. A set stores unique items and supports fast membership checks.

# for num in nums:
# Iterate through each number in the list.

# if num in seen:
# Check whether current number is already in the set. This is an O(1) average-time operation.

# return True
# If it’s already in the set, a duplicate exists — stop and return True.

# seen.add(num)
# If it wasn’t in the set, add it so future checks can detect it.

# return False
# If loop finishes without finding a repeat → all elements were unique → return False.

# Example trace for nums = [3,1,4,2,1]:

# seen = {}

# read 3 → not in seen → add → seen = {3}

# read 1 → not in seen → add → seen = {1,3}

# read 4 → add → seen = {1,3,4}

# read 2 → add → seen = {1,2,3,4}

# read 1 → 1 in seen True → return True.

# Complexity:
# Time: O(n) on average (each membership test and add is O(1) average).
# Space: O(n) worst-case to store the seen elements.     

                                                                                       |